#pragma config(Sensor, dgtl1,  rear_end_detection, sensorTouch)
#pragma config(Motor,  port3,           right_wheels,  tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port4,           left_wheels,   tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port5,           arm1,          tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port6,           arm2,          tmotorVex393HighSpeed_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           arm3,          tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port8,           arm4,          tmotorVex393HighSpeed_MC29, openLoop)
#pragma config(Motor,  port9,           arm5,          tmotorVex393HighSpeed_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

task main()
{
	int vert_stick, hor_stick;
	int left_motors, right_motors;
	int arms;
	int turn_cur, turn_target, turn_error, prev_turn_error = 0;
	float Kp = 0.1, Ki = 0.01, MV = 0;
	float Po, Io;
	float I_integral = 0;

	// SET UP GYRO
	SensorType[in8] = sensorNone;
	wait1Msec(1000);
	SensorType[in8] = sensorGyro;
	wait1Msec(1500);

	while(true){
		// DRIVING
		// inputs
		vert_stick = vexRT[Ch3];
		hor_stick = vexRT[Ch1];
		// deadzone
		if(-13 < vert_stick && vert_stick < 13){
			vert_stick = 0;
		}
		if(-13 < hor_stick && hor_stick< 13){
			hor_stick = 0;
		}
		// calculate speeds
		left_motors = vert_stick + hor_stick;
		right_motors = - vert_stick + hor_stick;
		// set speeds
		motor[left_wheels] = left_motors;
		motor[right_wheels] = right_motors;

		// Turn Assist
		// update gyro
		turn_cur = SensorValue[in8];
		writeDebugStream("%d ", turn_cur);
		// do turn assisst if button pressed
		if(vexRT[Btn8U]==1||vexRT[Btn8R]==1||vexRT[Btn8D]==1||vexRT[Btn8L]==1){
			// set turn target based on button pressed
			if(vexRT[Btn8U] == 1){
				turn_target = 0;
			}
			else if(vexRT[Btn8R] == 1){
				turn_target = 900;
			}
			else if(vexRT[Btn8D] == 1){
				turn_target = 1800;
			}
			else if(vexRT[Btn8L] == 1){
				turn_target = 2700;
			}
			// find current error (deviation from target)
			turn_error = turn_target - turn_cur;
			// calculat PI values
			Po = Kp * turn_error;
			I_integral += turn_error;
			Io = Ki * I_integral;
			// find 'Manipulated Value'
			MV = Po + Io;
			writeDebugStreamLine("error: %d\tP: %.2f\tI: %.2f\tMV: %.2f", turn_error, Po, Io, MV);
			prev_turn_error = turn_error;
			// TODO: make it do stuff
		} else {
			turn_error = 0;
			I_integral = 0;
		}


		// SHOOTING
		// buttons
		if(vexRT[Btn6U] == 1){
			arms = 128;
		}
		else if(vexRT[Btn6D] == 1){
			arms = -128;
		}
		else{
			arms = 0;
		}
		// set speeds
		motor[arm1] = -arms;
		motor[arm2] = -arms;
		motor[arm3] = arms;
		motor[arm4] = -arms;
		motor[arm5] = -arms;
	}
}
